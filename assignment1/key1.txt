LAB 
1.
m a n SP m a n Enter / s e a r c h Enter n n n q
m a n SP - K SP s p e c i f i c W o r d Enter

2.
w h i c h SP c p Enter
w h i c h SP w c Enter

3.
m a n SP f i n d j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j q
f i n d SP / u s r / b i n SP - e x e c u t a b l e SP - n a m e SP ‘ ? ‘ Enter
m a n SP w Enter q 
m a n SP X Enter q

4.
l s SP - l SP | SP g r e p SP e m a c s Enter

5.
m a n SP c h m o d Enter j j j j j j j j j j j j j j j j j j j j j j j j j j q

6.
m a n SP f i n d Enter / m t i m e n n q

7.
f i n d SP - m t i m e SP - 2 1 SP - t y p e SP d Enter

8.
w h i c h SP f i n d Enter
f i n d SP / b i n SP - t y p e SP l SP | SP w c Enter

9.
m a n SP l s Enter
f i n d SP - t y p e SP f SP | SP x a r g s SP l s SP / u s r / l i b SP - l t SP | SP 
t a i l SP - 1 Enter

10.
m a n SP l o c a l e Enter q
l o c a l e Enter

11.
e m a c s Enter C-h a s o r t Enter C-x RightArrow C-v

12.
e m a c s Enter C-h k C-m-a C-h k C-m-h

13.
e m a c s Enter C-h k C-g 

14.
e m a c s Enter C-h k C-y

15.
c d SP / u s r / b i n Enter
l s SP - l Enter
e m a c s Enter M-x d i r e d Enter Enter


HOMEWORK
1.1

C-s P U B L I C Enter

C-s L a Enter M-b

C-s s e l f Enter M-b

C-s a r r o w Enter M-b

C-e

C-a

(Commands have been used above)

Cursor keys were never used for the above commands

C-x C-c y

1.2

C-s < ! - Enter C-k Backspace Backspace Backspace

C-s D E Enter C-k Backspace Backspace Backspace Backspace 
Backspace Backspace Backspace

C-s < ! Enter C-k C-k C-k C-k C-k Backspace Backspace

C-s < ! Enter C-k Backspace Backspace . < / p >

C-s < ! Enter C-k Backspace Backspace

C-x C-c y

1.3

M-% A s s i g n m e n t SP 1 Enter A s s i g n m e n t SP 3 7 
Enter SP SP .

M-% U T F - 8 Enter U S - A S C I I Enter .

C-n C-n C-n C-n C-n C-n C-a C-o

C-x C-c y

1.4

M-> C-p C-p C-k C-p C-r < / h t m l Enter C-n C-y

C-n C-n C-n C-n C-n C-n C-n RightArrow C-k C-p C-p C-r < h 2 > L 
Enter C-n C-n C-y

M-> C-p C-p C-p C-p C-p C-p C-p C-p C-p C-p C-e LeftArrow LeftArrow 
LeftArrow LeftArrow LeftArrow LeftArrow LeftArrow LeftArrow LeftArrow 
LeftArrow LeftArrow LeftArrow C-k C-p C-r l i n e s Enter C-e 
Backspace Backspace Backspace Backspace Backspace C-y

M-> C-r < ! Enter Backspace DownArrow RightArrow Backspace DownArrow RightArrow Backspace UpArrow C-k C-k C-k C-k C-k C-p C-p C-r < h 2 > S C-n C-n C-y

M-> C-r < ! Enter C-k C-p C-p C-r < h 2 > H Enter C-n C-n C-y

C-SP M-v M-v C-p C-p C-p C-p C-p C-p C-p C-p C-p C-p C-p C-w

C-_

< ! - - M-> - - >

M-% < o l > Enter < O l > Enter SP SP SP SP SP SP SP 
(7 occurences found)

1.5

M-x mkdir Enter Backspace Backspace Backspace Backspace Backspace 
Backspace Backspace Backspace j u n k Enter

C-x C-f Backspace Backspace Backspace Backspace Backspace Backspace 
Backspace Backspace j u n k / h e l l o . c Enter

M-x c o m p i l e SP h e l l o Enter

M-x s h e l l Enter . / h e l l o 

C-x C-f h e l l o - o u t Enter C-u M-! ~ / j u n k / h e l l o Enter

C-SP M-> C-w C-y C-x C-f k e y 1 . t x t Enter M-> C-y

#include <stdio.h>
int
main (void)
{
  char n = '\n';
  char b = '\\';
  char q = '"';
  char const *p = "#include <stdio.h>%cint%cmain (void)%c{%c  char n = '%cn';%c  char b 
  = '%c%c';%c  char q = '%c';%c  char const *p = %c%s%c;%c  printf (p, n, n, n, n, b, n, 
  b, b, n, q, n, q, p, q, n, n, n, n);%c  return 0;%c}%c";
  printf (p, n, n, n, n, b, n, b, b, n, q, n, q, p, q, n, n, n, n);
  return 0;
}

1.6
( r a n d o m ) C-j

( s e t q SP x SP ( r a n d o m ) ) C-j

( s e t q SP y SP ( r a n d o m ) ) C-j

( * SP x SP y ) C-j
(incorrect result obtained)

M-: ( * SP x SP y ) Enter
(Same incorrect result obtained)

A machine can never actually generate a completely random number. 
The numbers generated by (random) are actually pseudo-random and are based
on an initial seed. Since the seed is the same at the beginning of 
an emacs session (unless we change it), the same sequence of 
numbers will be generated by (random).

Although I was unable to solve the final problem of the assignment, I used the 
following method to try to come up with an answer:

Firstly, I tried many random multiplications in Lisp in emacs and concluded that an
incorrect answer is only obtained when some sort of integer overflow is happening.
So, if I get to know the highest and lowest values supported by my machine, I could
compute the probability of all the possible products overflowing and thus causing an
incorrect output.
By going through the help manual of emacs (not man emacs, but C-h r in emacs), I came 
across two Lisp functions which I thought might lead me to my answer: 
(most-positive-fixnum) and (most-negative-fixnum). I assumed that these would output 
the largest and smallest integer value supported by my machine respectively. 

However, I was unable to
find a way to actually obtain an output from these commands as simply
executing them from the scratch buffer by typing them out and pressing C-j did not work. 
Hence, without the required data, I gave up on making my mathematical expression 
and started thinking about other ways I could find the answer. Unfortunately, no 
other method came to mind.

During lab, I contacted my TA about this but was still unable to find a solution. 

